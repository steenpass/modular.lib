////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   parallel.lib  Tools for Parallelization
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

OVERVIEW:
This library provides tools to do several computations in parallel. They
are aimed at ordinary Singular users as well as authors of Singular
libraries.
@* Even without this library, it is possible to execute self-defined
Singular commands in parallel using @ref{links}, but the handling of
such links can be quite tedious. With the pocedures described below,
this can be done by one-line commands.
@* There are many parallel 'skeletons' (i.e. ways in which parallel
tasks rely upon and interact with each other). A few of them are already
implemented. Future plans include an abstraction layer for modular
techniques, 'worker farms', and parallel tests.

SEE ALSO:  link, modstd_lib, assprimeszerodim_lib

KEYWORDS:  parallel.lib; Parallelization; Links, user interface;
           Skeletons for parallelization; Distributed computing

PROCEDURES:
  parallelWaitN(...)     execute several jobs in parallel,
                         wait for N of them to finish
  parallelWaitFirst(...) execute several jobs in parallel,
                         wait for the first to finish
  parallelWaitAll(...)   execute several jobs in parallel,
                         wait for all of them to finish
";

LIB "semaphore.lib";

proc parallelWaitN(list commands, list args, int N, list #)
"USAGE:  parallelWaitN(commands, args, N[, timeout, linktype, servers,
         maxmemory]); commands list, args list, N int, timeout int,
         linktype string, servers list, maxmemory intvec
RETURN:  a list, containing the results of commands[i] applied to arg[i],
         i = 1, ..., size(commands).
         @* The procedure waits for N jobs to finish.

         @* OPTIONAL PARAMETERS:

            An optional timeout in ms can be provided. Default is 0 which
            disables the timeout.

            Supported linktypes are up to now \"ssi\" and \"mp\", see
            @ref{Ssi links} and @ref{MP links}.

            Servers:
         @* Each server is given by a list containing the address of the server,
            the number of cores to use on this server and the command to start
            Singular.
         @* If the address is \"localhost\", the processes will be generated on
            the same machine using forks. If the command to start Singular is
            \"\" (the empty string), \"Singular\" will be used.
         @* Default is @code{list(\"localhost\", system(\"cpu\"), \"\")}.
         @* There are some obvious shortcuts for servers, e.g. \"myserver\" is
            a shortcut for
            @code{list(\"myserver\", [nb. of cores on myserver], \"\")}, or 3
            for @code{list(\"localhost\", 3, \"\")}.

            Memory limits:
         @* If an intvec maxmemory of size @code{size(commands)} is given, the
            i-th job will be killed if it uses more than maxmemory[i] MB of
            memory. If maxmemory[i] is 0, there will be no restraint for the
            i-th job. Default is @code{0:size(commands)}.
NOTE:       The entries of the list commands must be strings.
         @* The entries of the list args must be lists.
         @* The returned list may contain more than N results if several jobs
            finished \"at the same time\". It may contain less than N results in
            the case of timeout or errors occurring.
         @* MP links do not work with a 64 bit version of Singular. If you want
            to use MP links, make sure that MP is available. This can be checked
            by the Singular command @code{system(\"with\", \"MP\");}.
         @* The check whether the jobs exceed the memory sizes given by
            maxmemory is only done from time to time. This feature is
            experimental and should be used with care.
SEE ALSO: Ssi links, MP links, waitfirst, waitall
KEYWORDS: parallelWaitN; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelWaitN;} shows an example."
{
  // initialize the timer
  int oldtimerresolution = system("--ticks-per-sec");
  system("--ticks-per-sec", 1000);
  int t = rtimer;

  // auxiliary variables
  int i, j, m, tt;

  // read optional parameters
  list defaultserver = list("localhost", system("cpu"), "");
  list defaults = list(0, "ssi", list(defaultserver), 0:size(commands));
  for(i = 1; i <= size(defaults); i++)
  {
    if(typeof(#[i]) != typeof(defaults[i]))
    {
      # = insert(#, defaults[i], i-1);
    }
  }
  if(size(#) != size(defaults))
  {
    ERROR("wrong optional parameters");
  }
  for(j = size(#[3]); j > 0; j--)
  {
    if(typeof(#[3][j][1]) != typeof(defaultserver[1]))
    {
      #[3][j] = insert(#[3][j], defaultserver[1], 0);
    }
    defaultserver[3] = "";
    // only for ssi:tcp links, the default program is system("Singular")
    if(#[2] == "ssi" && #[3][j][1] != "localhost")
    {
      defaultserver[3] = system("Singular");
    }
    for(i = 2; i <= size(defaultserver); i++)
    {
      if(typeof(#[3][j][i]) != typeof(defaultserver[i]))
      {
        #[3][j] = insert(#[3][j], defaultserver[i], i-1);
      }
    }
    if(size(#[3][j]) != size(defaultserver))
    {
      ERROR("wrong declaration for server no. "+string(j));
    }
  }
  int timeout = #[1];
  string linktype = #[2];
  list servers = #[3];
  intvec maxmems = #[4];

  // error checking
  int njobs = size(commands);
  if(njobs != size(args))
  {
    ERROR("The number of commands does not match the number of lists"
         +newline+"of arguments.");
  }
  if(njobs == 0)
  {
    ERROR("no commands specified");
  }
  for(i = 1; i <= njobs; i++)
  {
    if(typeof(commands[i]) != "string")
    {
      ERROR("The first argument is not a list of strings.");
    }
    if(typeof(args[i]) != "list")
    {
      ERROR("The second argument is not a list of lists.");
    }
  }
  if(N < 0)
  {
    ERROR("The number of jobs which you want to wait for is negative.");
  }
  if(N > njobs)
  {
    ERROR("The number of jobs which you wnat to wait for is greater"
         +newline+"than the number of jobs itself.");
  }
  if(timeout < 0)
  {
    ERROR("The given timeout is negative.");
  }
  if(linktype != "ssi" && linktype != "mp")
  {
    ERROR("The given linktype is not recognized.");
  }
  int nservers = size(servers);
  if(nservers <= 0)
  {
    ERROR("no server specified");
  }
  for(i = 1; i <= nservers; i++)
  {
    if(servers[i][1] != "localhost")
    {
      if(system("sh", "ssh "+servers[i][1]+" exit"))
      {
        ERROR("Could not connect to server \""+servers[i][1]+"\"");
      }
    }
    if(servers[i][2] < 0)
    {
      ERROR("The number of cores to be used on server \""+servers[i][1]+"\""
           +newline+" is negative.");
    }
    if(servers[i][1] == "localhost")
    {
      int ncpus(i) = system("cpu");
    }
    else
    {
      if(linktype == "ssi")
      {
        link lcpu(i) = "ssi:tcp "+servers[i][1]+":"+servers[i][3];
      }
      else
      {
        if(program == "")
        {
          link lcpu(i) = "MPtcp:launch+" --MPhost "+servers[i][1];
        }
        else
        {
          link lcpu(i) = "MPtcp:launch+" --MPhost "+servers[i][1]
            +" --MPapplication "+servers[i][3];
        }
      }
      open(lcpu(i));
      write(lcpu(i), quote(system("cpu")));
      int ncpus(i) = read(lcpu(i));
      close(lcpu(i));
      kill lcpu(i);
    }
    if(servers[i][2] == 0)
    {
      servers[i][2] = ncpus(i);
    }
    else
    {
      if(servers[i][2] > ncpus(i))
      {
        ERROR("The number of cores to use on server \""+servers[i][1]+"\""
             +newline+"is greater than the number of available cores");
      }
    }
    if(servers[i][1] != "localhost")
    {
      if(system("sh", "ssh "+servers[i][1]+
                      " 'test -e `which "+servers[i][3]+"`'"))
      {
        ERROR("\""+servers[i][3]+"\" was not found on"
             +"\""+servers[i][1]+"\".");
      }
    }
  }
  if(size(maxmems) != njobs)
  {
    ERROR("The size of the intvec which specifies the maximal amount of memory"
         +newline+"to be used for each job does not match the number of jobs.");
  }
  int havemaxmem;
  for(i = 1; i <= njobs; i++)
  {
    if(maxmems[i] < 0)
    {
      ERROR("The maximal amount of memory to be used for job no. "+string(i)
           +"is negative.");
    }
    havemaxmem = havemaxmem+maxmems[i];
  }

  for(i = 1; i <= njobs; i++) {
    link l(i) = startTask(commands[i], args[i]);
  }
  list links = l(1..njobs);
  int nfinished;
  int wait;
  list results;
  for(i = njobs; i > 0; i--) {
    results[i] = list();
  }
  while(nfinished < N) {
    wait = waitfirst(links);
    results[wait] = waitTask(l(wait));
    links[wait] = def(0);
    nfinished++;
  }

  system("--ticks-per-sec", oldtimerresolution);
  return(results);
}
example
{
  "EXAMPLE:"; echo = 2;
  LIB "primdec.lib";
  ring r = 0, (x,y,z), lp;
  ideal i = z8+z6+4z5+4z3+4z2+4, y-z2;
  ideal j = 3x3y+x3+xy3+y2z2, 2x3z-xy-xz3-y4-z2, 2x2yz-2xy2+xz2-y4;
  list commands = list("std", "primdecGTZ", "primdecSY",
                       "std", "primdecGTZ", "primdecSY");
  list args = list(list(i), list(i), list(i), list(j), list(j), list(j));
  parallelWaitN(commands, args, 3);
}

proc parallelWaitFirst(list commands, list args, list #)
"USAGE:  parallelWaitFirst(commands, args[, timeout, linktype, servers,
         maxmemory]); commands list, args list, timeout int, linktype string,
         servers list, maxmemory intvec
RETURN:  a list, containing at least one (if no timeout occurs) of the results
         of commands[i] applied to arg[i], i = 1, ..., size(commands).
         @* The command
         @code{parallelWaitFirst(list commands, list args, list #)} is
         synonymous to
         @code{parallelWaitN(list commands, list args, 1, list #)}. See
         @ref{parallelWaitN} for details on optional arguments and other
         remarks.
SEE ALSO: Ssi links, MP links, waitfirst
KEYWORDS: parallelWaitFirst; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelWaitFirst;} shows an example."
{
  return(parallelWaitN(commands, args, 1, #));
}
example
{
  "EXAMPLE:"; echo = 2;
  LIB "primdec.lib";
  ring r = 0, (x,y,z), lp;
  ideal i = z8+z6+4z5+4z3+4z2+4, y-z2;
  list commands = list("primdecGTZ", "primdecSY");
  list args = list(list(i), list(i));
  parallelWaitFirst(commands, args);
}

proc parallelWaitAll(def commands, list args, list #)
"USAGE:  parallelWaitAll(commands, args[, timeout, linktype, servers,
         maxmemory]); commands list or string, args list, timeout int,
         linktype string, servers list, maxmemory intvec
RETURN:  a list, containing the results of commands[i] applied to arg[i],
         i = 1, ..., size(commands).
         @* The command
         @code{parallelWaitAll(list commands, list args, list #)} is
         synonymous to
         @code{parallelWaitN(list commands, list args, size(args), list #)}. See
         @ref{parallelWaitN} for details on optional arguments and other
         remarks.
         If commands is of type string, this is a shortcut for a list of size
         @code{size(args)} whose entries are just this string.
SEE ALSO: Ssi links, MP links, waitall
KEYWORDS: parallelWaitAll; Parallelization; Links, user interface;
          Skeletons for parallelization; Distributed computing
EXAMPLE:  @code{example parallelWaitAll;} shows an example."
{
  if(typeof(commands) != "list" && typeof(commands) != "string")
  {
    ERROR("invalid type of first argument");
  }
  if(typeof(commands) == "list")
  {
    return(parallelWaitN(commands, args, size(args), #));
  }
  else
  {
    list cmds;
    for(int i = size(args); i > 0; i--)
    {
      cmds[i] = commands;
    }
    return(parallelWaitN(cmds, args, size(args), #));
  }
}
example
{
  "EXAMPLE:"; echo = 2;
  ring r = 0, (x,y,z), dp;
  ideal i1 = z8+z6+4z5+4z3+4z2+4, y-z2;
  ideal i2 = x10+x9y2, y8-x2y7;
  ideal i3 = x3-2xy, x2y-2y2+x;
  string command = "std";
  list args = list(list(i1), list(i2), list(i3));
  parallelWaitAll(command, args);
}

// TODO
/// http://arxiv.org/abs/1005.5663v2
proc doModular(string command, list args, def primeTest,
  def deleteUnluckyPrimes, def pTest, def finalTest, list #)
{
  /* auxiliary variables */
  int i;

  /* read optional parameters */
  int ncores_available = NbModProcs();
  list defaults = list(ncores_available, ncores_available, 2);
  for(i = 1; i <= size(defaults); i++)
  {
    if(typeof(#[i]) != typeof(defaults[i]))
    {
      # = insert(#, defaults[i], i-1);
    }
  }
  if(size(#) != size(defaults))
  {
    ERROR("wrong optional parameters");
  }
  int n1 = #[1];   // nb. of primes before the first lifting
  int n2 = #[2];   // nb. of additional primes for the next lifting
  int growths = #[3];

  /* error checking */
  if (n1 < 1 || n2 < 1 || growths < 1) {
    ERROR("wrong optional parameters");
  }
  if (typeof(primeTest) != "proc" && typeof(primeTest) != "string") {
    ERROR("incorrect argument primeTest");
  }
  if (typeof(deleteUnluckyPrimes) != "proc"
    && typeof(deleteUnluckyPrimes) != "string") {
    ERROR("incorrect argument deleteUnluckyPrimes");
  }
  if (typeof(pTest) != "proc" && typeof(pTest) != "string") {
    ERROR("incorrect argument pTest");
  }
  if (typeof(finalTest) != "proc" && typeof(finalTest) != "string") {
    ERROR("incorrect argument finalTest");
  }

  /* define procs deleteUnluckyPrimes, pTest, and finalTest */
  if (typeof(primeTest) == "string") {
    if (primeTest == "") {
      kill primeTest;
      proc primeTest = primeTest_default;
    }
    else {
      ERROR("incorrect argument primeTest");
    }
  }
  if (typeof(deleteUnluckyPrimes) == "string") {
    if (deleteUnluckyPrimes == "") {
      kill deleteUnluckyPrimes;
      proc deleteUnluckyPrimes = deleteUnluckyPrimes_default;
    }
    else {
      ERROR("incorrect argument deleteUnluckyPrimes");
    }
  }
  if (typeof(pTest) == "string") {
    if (pTest == "") {
      kill pTest;
      proc pTest = pTest_default;
    }
    else {
      ERROR("incorrect argument pTest");
    }
  }
  if (typeof(finalTest) == "string") {
    if (finalTest == "") {
      kill finalTest;
      proc finalTest = finalTest_default;
    }
    else {
      ERROR("incorrect argument finalTest");
    }
  }

  /* modular computations */
  def result;
  def result_lift;
  list modargs;
  list modresults;
  list primes;
  bigint N = 1;
  while(1) {
    // compute list of primes
    if (size(primes) == 0) {
      primes = primeList(n1, primeTest, args);
    }
    else {
      primes = primeList(n2, primeTest, args, primes[1]);
      n2 = n2*growths;
    }

    // do computation modulo several primes
    modargs = list();
    for (i = size(primes); i > 0; i--) {
      modargs[i] = list(command, args, primes[i]);
    }
    modresults = parallelWaitAll("computeInCharP", modargs);

    // delete unlucky primes
    modresults = deleteUnluckyPrimes(modresults);

    // lift result
    if (typeof(result_lift) == "none") {
      result_lift = modresults[1][1];
    }
    result_lift, N = modlift(modresults, result_lift, N);

    // apply farey()
    result = farey(result_lift, N);

    // pTest
    if(!pTest(command, args, result, primes)) {
      continue;
    }

    // finalTest
    if(finalTest(command, args, result)) {
      break;
    }
  }

  /* return of result */
  return(result);
}

static proc primeList(int n, proc primeTest, list args, list #)
{
  int i;

  /* read optional parameters */
  int p = 2147483647;
  if (size(#) > 0) {
    if (size(#) > 1 || typeof(#[1]) != "int") {
      ERROR("wrong optional parameters");
    }
    p = #[1]-1;
    if (p < 2) {
      ERROR("wrong optional parameters");
    }
  }

  /* compute primes */
  list primes;
  for (i = n; i > 0; i--) {
    if (p < 2) {
      ERROR("no more primes");
    }
    p = prime(p);
    if (!primeTest(p, args)) {
      p--;
      continue;
    }
    primes[i] = p;
    p--;
  }

  return(primes);
}

proc computeInCharP(string command, list args, int p)
{
  def br = basering;
  list lbr = ringlist(br);
  if (typeof(lbr[1]) == "int") {
    lbr[1] = p;
  }
  else {
    lbr[1][1] = p;
  }
  def rp = ring(lbr);
  setring(rp);
  list args = fetch(br, args);
  execute("def result = "+command+"("+argsToString("args", size(args))+");");
  setring(br);
  def result = fetch(rp, result);
  return(list(result, p));
}

static proc primeTest_default(int p, list args)
{
  return(1);
}

static proc deleteUnluckyPrimes_default(list modresults)
{
  return(modresults);
}

/* works so far for the following types: ideal (to be continued) */
static proc modlift(list modresults, def result, bigint N)
{
  /* copy data to lists convenient for chinrem()
   * (don't blame me, it's the stupid Singular interpreter) */
  list L1;        // the individual results
  list L2;        // the corresponding primes
  int size_modresults = size(modresults);
  if(N != 1) {
    L1[size_modresults+1] = result;
    L2[size_modresults+1] = N;
  }
  int i;
  for (i = size_modresults; i > 0; i--) {
    L1[i] = modresults[i][1];
    L2[i] = modresults[i][2];
    N = N*L2[i];
  }

  /* apply chinrem() */
  result = chinrem(L1, L2);

  /* return result */
  return(result, N);
}

static proc pTest_default
{
  return(1);
}

static proc finalTest_default
{
  return(1);
}

static proc NbModProcs()
{
    int available = system("semaphore", "get_value", 0)+1;
    int nb;
    if (available < 16) {
        nb = ((10 div available)+1-(10%available == 0))*available;
    }
    else {   // gives approx. (log_2(available))^2
        int tmp = available;
        while (tmp > 1) {
            tmp = tmp div 2;
            nb++;
        }   // nb = log_2(available)
        nb = ((2*nb+1)*available) div (2^nb) + (nb-1)^2 - 2;
    }
    return(nb);
}

// TODO
/* worker farm */
static proc Create() {}

/* auxiliary procedures */
static proc watchlinks()
{
  list parent = list(mempatrol);
  list watchedlinks;
  int wait;
  int i, sys;
  while(1)
  {
    if(size(watchedlinks) == 0)
    {
      wait = waitall(parent);
    }
    else
    {
      wait = waitall(parent, 10000);
    }
    if(wait == -1)
    {
      ERROR("The main process crashed.");
    }
    if(wait)
    {
      def query = read(mempatrol);
      if(typeof(query) == "list")
      {
        watchedlinks = insert(watchedlinks, query);
      }
      else // in this case, typeof(query) is assumed to be "int", the
           // index of the link
      {
        for(i = size(watchedlinks); i > 0; i--)
        {
          if(watchedlinks[i][3] == query)
          {
            watchedlinks = delete(watchedlinks, i);
            break;
          }
        }
      }
    }
    for(i = size(watchedlinks); i > 0; i--)
    {
      if(getusedmemory(watchedlinks[i][1], watchedlinks[i][2])
           > watchedlinks[i][4])
      {
        if(watchedlinks[i][1] == "localhost")
        {
          sys = system("sh", "kill "+string(watchedlinks[i][2]));
        }
        else
        {
          sys = system("sh", "ssh "+watchedlinks[i][1]+" kill "
                             +string(watchedlinks[i][2]));
        }
        write(mempatrol, watchedlinks[i][3]);
        watchedlinks = delete(watchedlinks, i);
      }
    }
  }
}

static proc getusedmemory(string server, int pid)
{
  string s;
  if(server == "localhost")
  {
    s = read("|: grep VmSize /proc/"+string(pid)+"/status "+
             "| awk '{ print $2; }'");
  }
  else
  {
    s = read("|: ssh "+server+" grep VmSize /proc/"+string(pid)+"/status "+
             "| awk '{ print $2; }'");
  }
  bigint b;
  execute("b = "+s+";");
  int i = int(b/1000);
  return(i);
}

