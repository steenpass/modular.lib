ring r = 0,(x,y,z),dp;
ideal i = x;
ideal j = y;
list commands = list("std", "std");
list args = list(list(i), list(j));

proc doInParWaitN(list commands, list args, int N, list #)
{
  // initialize the timer
  int oldtimerresolution = system("--ticks-per-sec");
  system("--ticks-per-sec", 1000);
  int t = rtimer;

  // auxiliary variables
  int i, j;

  // read optional parameters
  list defaults = list(0, "ssi", list(list("localhost", 0)));
  for(i = 1; i <= 3; i++)
  {
    if(typeof(#[i]) != typeof(defaults[i]))
    {
      # = insert(#, defaults[i], i-1);
    }
  }
  if(size(#) != 3)
  {
    ERROR("wrong optional parameters");
  }
  int timeout = #[1];
  string linktype = #[2];
  list servers = #[3];

  // error checking
  int njobs = size(commands);
  if(njobs != size(args))
  {
    ERROR("The number of commands does not match the number of lists\n"
         +"of arguments.");
  }
  if(njobs == 0)
  {
    ERROR("no commands specified");
  }
  for(i = 1; i <= njobs; i++)
  {
    if(typeof(commands[i]) != "string")
    {
      ERROR("The first argument is not a list of strings.");
    }
    if(typeof(args[i]) != "list")
    {
      ERROR("The second argument is not a list of lists.");
    }
  }
  if(N < 0)
  {
    ERROR("The number of jobs which you want to wait for is negative.");
  }
  if(N > njobs)
  {
    ERROR("The number of jobs which you wnat to wait for is greater\n"
         +"than the number of jobs itself.");
  }
  if(timeout < 0)
  {
    ERROR("The given timeout is negative.");
  }
  if(linktype != "ssi" && linktype != "mp")
  {
    ERROR("The given linktype is not recognized.");
  }
  int nservers = size(servers);
  if(nservers <= 0)
  {
    ERROR("no server specified");
  }
  for(i = 1; i <= nservers; i++)
  {
    if(typeof(servers[i] == "int"))   // shortcut
    {
      servers[i] = list("localhost", servers[i]);
    }
    else if(typeof(servers[i] == "string"))   // shortcut
    {
      servers[i] = list(servers[i], 0);
    }
    else if(typeof(servers[i] == "list"))
    {
      if(typeof(servers[i][1] != "string") || typeof(servers[i][2] != "int"))
      {
        ERROR("wrong declaration for server no. "+string(i));
      }
    }
    else
    }
      ERROR("wrong declaration for server no. "+string(i));
    }
    if(servers[i][1] != "localhost")
    {
      if(system("sh", "ssh "+servers[i][1]+" exit"))
      {
        ERROR("Could not connect to server "+servers[i][1]);
      }
    }
    if(servers[i][2] < 0)
    {
      ERROR("The number of cores to be used on server no. "+string(i)
           +" is negative.");
    }
    if(servers[i][1] == "localhost")
    {
      int ncpus(i) = system("cpu");
    }
    else
    {
      if(linktype == "ssi")
      {
        link lcpu(i) = "ssi:tcp "+servers[i][1];
      }
      else
      {
        link lcpu(i) = "MPtcp:launch "+servers[i][1];
      }
      open(lcpu(i));
      write(lcpu(i), quote(system("cpu")));
      int ncpus(i) = read(lcpus(i));
      close(lcpu(i));
      kill lcpu(i);
    }
    if(servers[i][2] == 0)
    {
      servers[i][2] == ncpus(i);
    }
    else if(servers[i][2] > ncpus(i))
    {
      ERROR("The number of cores to use on server no. "+string(i)+" is greater\n"
           +"than the number of available cores");
    }
  }

  // skip those cores which won't be needed
  int nlinks;
  for(i = 1; i <= nservers; i++)
  {
    if(nlinks+servers[i][2] <= njobs)
    {
      nlinks += servers[i][2];
    }
    else
    {
      if(nlinks == njobs)
      {
        servers = list(servers[1..(i-1)]);
      }
      else
      {
        servers = list(servers[1..i]);
        servers[i][2] = njobs-nlinks;
        nlinks = njobs;
      }
      nservers = size(servers);
    }
  }

  // open the links and distribute work to each of them
  intvec assignment = 0:nlinks;  // link number i is currently doing job number assignment[i]
  string server;
  int ncores;
  int k = 1;   // the index of the next job which has to be distributed to some link
  for(i = 1; i <= nservers; i++)
  {
    server = servers[i][1];
    ncores = servers[i][2];
    for(j = 1; j <= ncores; j++)
    {
      if(server == "localhost")
      {
        if(linktype == "ssi")
        {
          link l(k) = "ssi:fork";
        }
        else
        {
          link l(k) = "MPtcp:fork";
        }
        open(l(k));
      }
      else
      {
        if(linktype == "ssi")
        {
          link l(k) = "ssi:tcp "+server;
        }
        else
        {
          link l(k) = "MPtcp:launch "+server;
        }
        open(l(k));
        write(l(k), quote(execute("list args;")));
        read(l(k));
        write(l(k), quote(args = eval(args)));
        read(l(k));
      }
      write(l(k), quote(execute("def result;")));
      read(l(k));
      write(l(k), quote(execute("list currentargs;")));
      read(l(k));
      write(l(k), quote(currentargs = args[eval(k)]));
      read(l(k));
      write(l(k), quote(execute("result = "+eval(commands[k])+"(currentargs[1..size(currentargs)]);")));
      assignment[k] = k;
      k++;
    }
  }
  list links = list(l(1..nlinks));

  // distribute the rest of the work
  list results;
  for(i = njobs; i > 0; i--)
  {
    results[i] = list();
  }
  int nfinished;  // the number of finished jobs
  int wait;   // the index of the link which is finished, or 0 for timeout
  while(k <= njobs && nfinished < N-1)
  {
    if(timeout == 0)
    {
      wait = waitfirst(links);
    }
    else
    {
      wait = waitfirst(links, timeout-(rtimer-t));
    }
    if(wait)
    {
      read(l(wait));
      write(l(wait), quote(result));
      results[assignment[wait]] = read(l(wait));
      nfinished++;
      write(l(wait), quote(currentargs = args[eval(k)]));
      read(l(wait));
      write(l(wait), quote(execute("result = "+eval(commands[k])+"(currentargs[1..size(currentargs)]);")));
      assignment[wait] = k;
      k++;
    }
    else
    {
      break;
    }
  }

  // collect the rest of the results and close all links
  while(nfinished < N)
  {
    if(timeout == 0)
    {
      wait = waitfirst(links);
    }
    else
    {
      wait = waitfirst(links, timeout-(rtimer-t));
    }
    if(wait)
    {
      read(l(wait));
      write(l(wait), quote(result));
      results[assignment[wait]] = read(l(wait));
      nfinished++;
    }
    else
    {
      break;
    }
  }
  for(i = 1; i <= nlinks; i++)
  {
    if(status(l(i), "read", "ready"))
    {
      read(l(i));
      write(l(i), quote(result));
      results[assignment[i]] = read(l(i));
    }
    close(l(i));
  }

  system("--ticks-per-sec", oldtimerresolution);
  return(results);
}

proc doInParWaitFirst(list commands, list args, list #)
{
  return(doInParWaitN(commands, args, 1, #));
}

proc doInParWaitAll(list commands, list args, list #)
{
  return(doInParWaitN(commands, args, size(commands), #));
}


proc doInParWaitAllSingleCmd(string cmd, list args, list #)
{
  list commands;
  for(int i = size(args); i > 0; i--)
  {
    commands[i] = cmd;
  }
  return(doInParWaitAll(commands, args, #));
}

proc doModular(command, args, proc deleteUnlucksPrimes, proc testInChar0)
{
}

/* worker farm */
proc Create () {}
