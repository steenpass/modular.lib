proc primeTest_modstd(int p, list args)
{
   def II = args[1];

   if(typeof(II) == "string")
   {
      execute("ideal I = "+II+";");
   }
   else
   {
      ideal I = II;
   }

   int i,j;
   poly f;
   number cnt;
   for(i = 1; i <= size(I); i++)
   {
      f = cleardenom(I[i]);
      if(f == 0) { return(0); }
      cnt = leadcoef(I[i])/leadcoef(f);
      if((numerator(cnt) mod p) == 0) { return(0); }
      if((denominator(cnt) mod p) == 0) { return(0); }
      for(j = size(f); j > 0; j--)
      {
         if((leadcoef(f[j]) mod p) == 0) { return(0); }
      }
   }
   return(1);
}

proc deleteUnluckyPrimes_modstd(list modresults)
{
   list T;
   list L;
   int ii;
   for (ii = size(modresults); ii > 0; ii--) {
       T[ii] = modresults[ii][1];
       L[ii] = modresults[ii][2];
   }
   int ho;
   list #;

   ho = ((ho)||(ord_test(basering) == -1));
   int j,k,c;
   intvec hl,hc;
   ideal cT,lT,cK;
   lT = lead(T[size(T)]);
   attrib(lT,"isSB",1);
   if(!ho)
   {
      for(j = 1; j < size(T); j++)
      {
         cT = lead(T[j]);
         attrib(cT,"isSB",1);
         if((size(reduce(cT,lT))!=0)||(size(reduce(lT,cT))!=0))
         {
            cK = cT;
            c++;
         }
      }
      if(c > size(T) div 2){ lT = cK; }
   }
   else
   {
      hl = hilb(lT,1);
      for(j = 1; j < size(T); j++)
      {
         cT = lead(T[j]);
         attrib(cT,"isSB",1);
         hc = hilb(cT,1);
         if(hl == hc)
         {
            for(k = 1; k <= size(lT); k++)
            {
               if(lT[k] < cT[k]) { lT = cT; c++; break; }
               if(lT[k] > cT[k]) { c++; break; }
            }
         }
         else
         {
            if(hc < hl){ lT = cT; hl = hilb(lT,1); c++; }
         }
      }
   }

   int addList;
   if(size(#) > 0) { list M = #; addList = 1; }
   j = 1;
   attrib(lT,"isSB",1);
   while((j <= size(T))&&(c > 0))
   {
      cT = lead(T[j]);
      attrib(cT,"isSB",1);
      if((size(reduce(cT,lT)) != 0)||(size(reduce(lT,cT)) != 0))
      {
         T = delete(T,j);
         if(j == 1)
         {
            L = L[2..size(L)];
            if(addList == 1) { M = M[2..size(M)]; }
         }
         else
         {
            if(j == size(L))
            {
               L = L[1..size(L)-1];
               if(addList == 1) { M = M[1..size(M)-1]; }
            }
            else
            {
               L = L[1..j-1],L[j+1..size(L)];
               if(addList == 1) { M = M[1..j-1],M[j+1..size(M)]; }
            }
         }
         j--;
      }
      j++;
   }

   for(j = 1; j <= size(L); j++)
   {
      L[j] = bigint(L[j]);
   }

   modresults = list();
   for (ii = size(T); ii > 0; ii--) {
       modresults[ii] = list();
       modresults[ii][1] = T[ii];
       modresults[ii][2] = L[ii];
   }
   return(modresults);

   if(addList == 0) { return(list(T,L,lT)); }
   if(addList == 1) { return(list(T,L,M,lT)); }
}

proc pTest_modstd(string command, list args, def result, list primes)
{
   ideal I = args[1];
   ideal J = result;
   list L;
   int pp = prime(2147483647);
   while (pp >= primes[1]) {
       L[size(L)+1] = pp;
       pp = prime(pp-1);
   }
   int variant;
   if (command == "groebner") {
       variant = 2;
   }
   else {
       ERROR("which variant?");
   }
   list #;

   int i,j,k,p;
   def R = basering;
   list r = ringlist(R);

   while(!j)
   {
      j = 1;
      p = prime(random(1000000000,2134567879));
      for(i = 1; i <= size(L); i++)
      {
         if(p == L[i]) { j = 0; break; }
      }
      if(j)
      {
         for(i = 1; i <= ncols(I); i++)
         {
            for(k = 2; k <= size(I[i]); k++)
            {
               if((denominator(leadcoef(I[i][k])) mod p) == 0) { j = 0; break; }
            }
            if(!j){ break; }
         }
      }
      if(j)
      {
         if(!primeTest(I,p)) { j = 0; }
      }
   }
   r[1] = p;
   def @R = ring(r);
   setring @R;
   ideal I = imap(R,I);
   ideal J = imap(R,J);
   attrib(J,"isSB",1);

   int t = timer;
   j = 1;
   if(isIncluded(I,J) == 0) { j = 0; }

   if(printlevel >= 11)
   {
      "isIncluded(I,J) takes "+string(timer - t)+" seconds";
      "j = "+string(j);
   }

   t = timer;
   if(j)
   {
      if(size(#) > 0)
      {
         ideal K = modpStd(I,p,variant,#[1])[1];
      }
      else
      {
         ideal K = groebner(I);
      }
      t = timer;
      if(isIncluded(J,K) == 0) { j = 0; }

      if(printlevel >= 11)
      {
         "isIncluded(J,K) takes "+string(timer - t)+" seconds";
         "j = "+string(j);
      }
   }
   setring R;
   return(j);
}

proc finalTest_modstd(string command, list args, ideal result)
{
    attrib(J,"isSB",1);

    sizeTest = 1 - isIncluded(I,J,n1);

    if(sizeTest == 0)
    {
        K = std(J);

        if(size(reduce(K,J)) == 0)
        {
            return(J);
        }
    }
}

