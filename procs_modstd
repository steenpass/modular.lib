proc primeTest_modstd(int p, list args)
{
   def II = args[1];

   if(typeof(II) == "string")
   {
      execute("ideal I = "+II+";");
   }
   else
   {
      ideal I = II;
   }

   int i,j;
   poly f;
   number cnt;
   for(i = 1; i <= size(I); i++)
   {
      f = cleardenom(I[i]);
      if(f == 0) { return(0); }
      cnt = leadcoef(I[i])/leadcoef(f);
      if((numerator(cnt) mod p) == 0) { return(0); }
      if((denominator(cnt) mod p) == 0) { return(0); }
      for(j = size(f); j > 0; j--)
      {
         if((leadcoef(f[j]) mod p) == 0) { return(0); }
      }
   }
   return(1);
}

proc deleteUnluckyPrimes_modstd(list modresults)
{
   list T;
   list L;
   int ii;
   for (ii = size(modresults); ii > 0; ii--) {
       T[ii] = modresults[ii][1];
       L[ii] = modresults[ii][2];
   }
   int ho;
   list #;

   ho = ((ho)||(ord_test(basering) == -1));
   int j,k,c;
   intvec hl,hc;
   ideal cT,lT,cK;
   lT = lead(T[size(T)]);
   attrib(lT,"isSB",1);
   if(!ho)
   {
      for(j = 1; j < size(T); j++)
      {
         cT = lead(T[j]);
         attrib(cT,"isSB",1);
         if((size(reduce(cT,lT))!=0)||(size(reduce(lT,cT))!=0))
         {
            cK = cT;
            c++;
         }
      }
      if(c > size(T) div 2){ lT = cK; }
   }
   else
   {
      hl = hilb(lT,1);
      for(j = 1; j < size(T); j++)
      {
         cT = lead(T[j]);
         attrib(cT,"isSB",1);
         hc = hilb(cT,1);
         if(hl == hc)
         {
            for(k = 1; k <= size(lT); k++)
            {
               if(lT[k] < cT[k]) { lT = cT; c++; break; }
               if(lT[k] > cT[k]) { c++; break; }
            }
         }
         else
         {
            if(hc < hl){ lT = cT; hl = hilb(lT,1); c++; }
         }
      }
   }

   int addList;
   if(size(#) > 0) { list M = #; addList = 1; }
   j = 1;
   attrib(lT,"isSB",1);
   while((j <= size(T))&&(c > 0))
   {
      cT = lead(T[j]);
      attrib(cT,"isSB",1);
      if((size(reduce(cT,lT)) != 0)||(size(reduce(lT,cT)) != 0))
      {
         T = delete(T,j);
         if(j == 1)
         {
            L = L[2..size(L)];
            if(addList == 1) { M = M[2..size(M)]; }
         }
         else
         {
            if(j == size(L))
            {
               L = L[1..size(L)-1];
               if(addList == 1) { M = M[1..size(M)-1]; }
            }
            else
            {
               L = L[1..j-1],L[j+1..size(L)];
               if(addList == 1) { M = M[1..j-1],M[j+1..size(M)]; }
            }
         }
         j--;
      }
      j++;
   }

   for(j = 1; j <= size(L); j++)
   {
      L[j] = bigint(L[j]);
   }

   modresults = list();
   for (ii = size(T); ii > 0; ii--) {
       modresults[ii] = list();
       modresults[ii][1] = T[ii];
       modresults[ii][2] = L[ii];
   }
   return(modresults);

   if(addList == 0) { return(list(T,L,lT)); }
   if(addList == 1) { return(list(T,L,M,lT)); }
}

