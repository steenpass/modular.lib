////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   modular.lib  An abstraction layer for modular techniques
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

OVERVIEW:
This library is an abstraction layer for modular techniques which are
well-known to speed up many computations and to be easy parallelizable.
@* The basic idea is to execute some computation modulo several primes and then
to lift the result back to characteristic zero via the farey rational map and
chinese remaindering. It is thus possible to overcome the often problematic
coefficient swell and to run the modular computations in parallel.
@* In Singular, modular techniques have been quite successfully employed for
several applications. A first implementation was done for Groebner bases in
Singular's @ref{modstd.lib}, a pioneering work by Stefan Steidel. Since the
algorithm is basically the same for all applications, this library aims at
preventing library authors from writing the same code over and over again by
providing an appropriate abstraction layer. It also offers one-line commands
for ordinary Singular users who want to take advantage of modular techniques
for their own calculations. Thus modular techniques can be regarded as
a parallel skeleton of their own.
@* The terminology (such as 'pTest' and 'finalTest') follows Singular's
@ref{modstd.lib} and [1].

REFERENCES:
[1] Nazeran Idrees, Gerhard Pfister, Stefan Steidel: Parallelization of
    Modular Algorithms. Journal of Symbolic Computation 46, 672-684 (2011).
    http://arxiv.org/abs/1005.5663

SEE ALSO:  link, semaphore_lib, parallel_lib, modstd_lib, assprimeszerodim_lib

KEYWORDS:  modular.lib; Modular techniques; Parallelization;
           Skeletons for parallelization; Distributed computing

PROCEDURES:
  modular(...)  execute a command modulo several primes and lift the result
                back to charakteristic zero
";

LIB "resources.lib";
LIB "tasks.lib";
LIB "parallel.lib";

static proc mod_init()
{
    if (!defined(Resources)) {
        LIB "resources.lib";
    }
    int sem_cores = Resources::sem_cores;   // the number of processor cores
    exportto(Modular, sem_cores);
}

proc modular(string Command, alias list Arguments, list #)
{
    /* auxiliary variables */
    int i;

    /* read optional parameters */
    list defaults = list(primeTest_default, deleteUnluckyPrimes_default,
        pTest_default, finalTest_default, 2147483647);
    for (i = 1; i <= size(defaults); i++) {
        if (typeof(#[i]) != typeof(defaults[i])) {
            # = insert(#, defaults[i], i-1);
        }
    }
    if (size(#) != size(defaults)) {
        ERROR("wrong optional parameters");
    }
    proc primeTest = #[1];
    proc deleteUnluckyPrimes = #[2];
    proc pTest = #[3];
    proc finalTest = #[4];
    int pmax = #[5];

    /* export command and arguments */
    exportto(Modular, Command);
    exportto(Modular, Arguments);

    /* modular computations */
    def result;
    def result_lift;
    bigint N = 1;
    list modresults;
    list primes;
    int nAllPrimes;
    int nNewPrimes;
    list indices;
    int ncores_available;
    while (1) {
        // compute list of primes
        if (nAllPrimes == 0) {
            nNewPrimes = NbModProcs();
        }
        else {
            ncores_available = system("semaphore", "get_value", sem_cores)+1;
            nNewPrimes = (nAllPrimes div ncores_available)*ncores_available;
        }
        primes = primeList(primeTest, nNewPrimes, pmax);
        pmax = primes[size(primes)]-1;
        nAllPrimes = nAllPrimes+nNewPrimes;

        // do computation modulo several primes
        for (i = size(primes); i > 0; i--) {
            task t(i) = "Modular::modp", primes[i];
        }
        startTasks(t(1..size(primes)));
        waitAllTasks(t(1..size(primes)));
        for (i = size(primes); i > 0; i--) {
            modresults[i] = getResult(t(i));
            killTask(t(i));
            kill t(i);
        }

        // delete unlucky primes
        indices = deleteUnluckyPrimes(modresults);
        for (i = size(indices); i > 0; i--) {
            modresults = delete(modresults, indices[i]);
        }

        // lift result
        if (N == 1) {
            result_lift = chinrem(modresults, primes);
        }
        else {
            result_lift = chinrem(list(result_lift)+modresults,
                list(N)+primes);
        }
        for (i = size(primes); i > 0; i--) {
            N = N*primes[i];
        }

        // apply farey
        result = farey(result_lift, N);

        // pTest
        if (!pTest(Command, Arguments, result, pmax)) {
            continue;
        }

        // finalTest
        if (finalTest(Command, Arguments, result)) {
            break;
        }
    }

    /* kill command and arguments */
    kill Command;
    kill Arguments;

    /* return of result */
    return(result);
}

static proc primeList(proc primeTest, int n, int pmax)
{
    list primes;
    int p = pmax;
    int i;
    for (i = 1; i <= n; i++) {
        if (p < 2) {
            ERROR("no more primes");
        }
        p = prime(p);
        if (!primeTest(p, Arguments)) {
            p--;
            continue;
        }
        primes[i] = p;
        p--;
    }
    return(primes);
}

static proc modp(int p)
{
    def br = basering;
    list lbr = ringlist(br);
    if (typeof(lbr[1]) == "int") {
        lbr[1] = p;
    }
    else {
        lbr[1][1] = p;
    }
    def rp = ring(lbr);
    setring(rp);
    list args = fetch(br, Arguments);
    execute("def result = "+Command+"("+Tasks::argsToString("args", size(args))
        +");");
    setring(br);
    def result = fetch(rp, result);
    return(result);
}

static proc primeTest_default(int p, alias list args)
{
    return(1);
}

static proc deleteUnluckyPrimes_default(alias list modresults)
{
    return(list());
}

static proc pTest_default(string command, alias list args, def result,
    int pmax)
{
    return(1);
}

static proc finalTest_default(string command, alias list args, def result)
{
    return(1);
}

static proc NbModProcs()
{
    int available = system("semaphore", "get_value", sem_cores)+1;
    int nb;
    if (available < 16) {
        nb = ((10 div available)+1-(10%available == 0))*available;
    }
    else {   // gives approx. (log_2(available))^2
        int tmp = available;
        while (tmp > 1) {
            tmp = tmp div 2;
            nb++;
        }   // nb = log_2(available)
        nb = ((2*nb+1)*available) div (2^nb) + (nb-1)^2 - 2;
    }
    return(nb);
}

