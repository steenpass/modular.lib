////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   modular.lib  An abstraction layer for modular techniques
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

OVERVIEW:
This library is an abstraction layer for modular techniques which are
well-known to speed up many computations and to be easy parallelizable.
@* The basic idea is to execute some computation modulo several primes and then
to lift the result back to characteristic zero via the farey rational map and
chinese remaindering. It is thus possible to overcome the often problematic
coefficient swell and to run the modular computations in parallel.
@* In Singular, modular techniques have been quite successfully employed for
several applications. A first implementation was done for Groebner bases in
Singular's @ref{modstd.lib}, a pioneering work by Stefan Steidel. Since the
algorithm is basically the same for all applications, this library aims at
preventing library authors from writing the same code over and over again by
providing an appropriate abstraction layer. It also offers one-line commands
for ordinary Singular users who want to take advantage of modular techniques
for their own calculations. Thus modular techniques can be regarded as
a parallel skeleton of their own.
@* The terminology (such as 'pTest' and 'finalTest') follows Singular's
@ref{modstd.lib} and [1].

REFERENCES:
[1] Nazeran Idrees, Gerhard Pfister, Stefan Steidel: Parallelization of
    Modular Algorithms. Journal of Symbolic Computation 46, 672-684 (2011).
    http://arxiv.org/abs/1005.5663

SEE ALSO:  link, semaphore_lib, parallel_lib, modstd_lib, assprimeszerodim_lib

KEYWORDS:  modular.lib; Modular techniques; Parallelization;
           Skeletons for parallelization; Distributed computing

PROCEDURES:
  doModular(...)      execute a command modulo several primes and
                      lift the result back to charakteristic zero
  computeInCharP(...) execute a command modulo a single prime
";

LIB "parallel.lib";

proc doModular(string command, list args, def primeTest,
  def deleteUnluckyPrimes, def pTest, def finalTest, list #)
{
  /* auxiliary variables */
  int i;

  /* read optional parameters */
  int ncores_available = NbModProcs();
  list defaults = list(ncores_available, ncores_available, 2);
  for(i = 1; i <= size(defaults); i++)
  {
    if(typeof(#[i]) != typeof(defaults[i]))
    {
      # = insert(#, defaults[i], i-1);
    }
  }
  if(size(#) != size(defaults))
  {
    ERROR("wrong optional parameters");
  }
  int n1 = #[1];   // nb. of primes before the first lifting
  int n2 = #[2];   // nb. of additional primes for the next lifting
  int growths = #[3];

  /* error checking */
  if (n1 < 1 || n2 < 1 || growths < 1) {
    ERROR("wrong optional parameters");
  }
  if (typeof(primeTest) != "proc" && typeof(primeTest) != "string") {
    ERROR("incorrect argument primeTest");
  }
  if (typeof(deleteUnluckyPrimes) != "proc"
    && typeof(deleteUnluckyPrimes) != "string") {
    ERROR("incorrect argument deleteUnluckyPrimes");
  }
  if (typeof(pTest) != "proc" && typeof(pTest) != "string") {
    ERROR("incorrect argument pTest");
  }
  if (typeof(finalTest) != "proc" && typeof(finalTest) != "string") {
    ERROR("incorrect argument finalTest");
  }

  /* define procs deleteUnluckyPrimes, pTest, and finalTest */
  if (typeof(primeTest) == "string") {
    if (primeTest == "") {
      kill primeTest;
      proc primeTest = primeTest_default;
    }
    else {
      ERROR("incorrect argument primeTest");
    }
  }
  if (typeof(deleteUnluckyPrimes) == "string") {
    if (deleteUnluckyPrimes == "") {
      kill deleteUnluckyPrimes;
      proc deleteUnluckyPrimes = deleteUnluckyPrimes_default;
    }
    else {
      ERROR("incorrect argument deleteUnluckyPrimes");
    }
  }
  if (typeof(pTest) == "string") {
    if (pTest == "") {
      kill pTest;
      proc pTest = pTest_default;
    }
    else {
      ERROR("incorrect argument pTest");
    }
  }
  if (typeof(finalTest) == "string") {
    if (finalTest == "") {
      kill finalTest;
      proc finalTest = finalTest_default;
    }
    else {
      ERROR("incorrect argument finalTest");
    }
  }

  /* modular computations */
  def result;
  def result_lift;
  list modargs;
  list modresults;
  list primes;
  bigint N = 1;
  while(1) {
    // compute list of primes
    if (size(primes) == 0) {
      primes = primeList(n1, primeTest, args);
    }
    else {
      primes = primeList(n2, primeTest, args, primes[1]);
      n2 = n2*growths;
    }

    // do computation modulo several primes
    modargs = list();
    for (i = size(primes); i > 0; i--) {
      modargs[i] = list(command, args, primes[i]);
    }
    modresults = parallelWaitAll("computeInCharP", modargs);

    // delete unlucky primes
    modresults = deleteUnluckyPrimes(modresults);

    // lift result
    if (typeof(result_lift) == "none") {
      result_lift = modresults[1][1];
    }
    result_lift, N = modlift(modresults, result_lift, N);

    // apply farey()
    result = farey(result_lift, N);

    // pTest
    if(!pTest(command, args, result, primes)) {
      continue;
    }

    // finalTest
    if(finalTest(command, args, result)) {
      break;
    }
  }

  /* return of result */
  return(result);
}

static proc primeList(int n, proc primeTest, list args, list #)
{
  int i;

  /* read optional parameters */
  int p = 2147483647;
  if (size(#) > 0) {
    if (size(#) > 1 || typeof(#[1]) != "int") {
      ERROR("wrong optional parameters");
    }
    p = #[1]-1;
    if (p < 2) {
      ERROR("wrong optional parameters");
    }
  }

  /* compute primes */
  list primes;
  for (i = n; i > 0; i--) {
    if (p < 2) {
      ERROR("no more primes");
    }
    p = prime(p);
    if (!primeTest(p, args)) {
      p--;
      continue;
    }
    primes[i] = p;
    p--;
  }

  return(primes);
}

proc computeInCharP(string command, list args, int p)
{
  def br = basering;
  list lbr = ringlist(br);
  if (typeof(lbr[1]) == "int") {
    lbr[1] = p;
  }
  else {
    lbr[1][1] = p;
  }
  def rp = ring(lbr);
  setring(rp);
  list args = fetch(br, args);
  execute("def result = "+command+"("+argsToString("args", size(args))+");");
  setring(br);
  def result = fetch(rp, result);
  return(list(result, p));
}

static proc primeTest_default(int p, list args)
{
  return(1);
}

static proc deleteUnluckyPrimes_default(list modresults)
{
  return(modresults);
}

/* works so far for the following types: ideal (to be continued) */
static proc modlift(list modresults, def result, bigint N)
{
  /* copy data to lists convenient for chinrem()
   * (don't blame me, it's the stupid Singular interpreter) */
  list L1;        // the individual results
  list L2;        // the corresponding primes
  int size_modresults = size(modresults);
  if(N != 1) {
    L1[size_modresults+1] = result;
    L2[size_modresults+1] = N;
  }
  int i;
  for (i = size_modresults; i > 0; i--) {
    L1[i] = modresults[i][1];
    L2[i] = modresults[i][2];
    N = N*L2[i];
  }

  /* apply chinrem() */
  result = chinrem(L1, L2);

  /* return result */
  return(result, N);
}

static proc pTest_default
{
  return(1);
}

static proc finalTest_default
{
  return(1);
}

static proc NbModProcs()
{
    int available = system("semaphore", "get_value", 0)+1;
    int nb;
    if (available < 16) {
        nb = ((10 div available)+1-(10%available == 0))*available;
    }
    else {   // gives approx. (log_2(available))^2
        int tmp = available;
        while (tmp > 1) {
            tmp = tmp div 2;
            nb++;
        }   // nb = log_2(available)
        nb = ((2*nb+1)*available) div (2^nb) + (nb-1)^2 - 2;
    }
    return(nb);
}

