////////////////////////////////////////////////////////////////////
version="$Id$";
category="General purpose";
info="
LIBRARY:   parallel.lib  Tools for Parallelization
AUTHOR:    Andreas Steenpass, e-mail: steenpass@mathematik.uni-kl.de

OVERVIEW:
This library provides tools to do several computations in parallel. They
are aimed at ordinary Singular users as well as authors of Singular
libraries.
@* Even without this library, it is possible to execute self-defined
Singular commands in parallel using @ref{links}, but the handling of
such links can be quite tedious. With the pocedures described below,
this can be done by one-line commands.
@* There are many parallel 'skeletons' (i.e. ways in which parallel
tasks rely upon and interact with each other). A few of them are already
implemented. Future plans include an abstraction layer for modular
techniques, 'worker farms', and parallel tests.

SEE ALSO:  link, semaphore_lib, modstd_lib, assprimeszerodim_lib

KEYWORDS:  parallel.lib; Parallelization; Links, user interface;
           Skeletons for parallelization; Distributed computing

PROCEDURES:
  parallelWaitN(...)     execute several jobs in parallel,
                         wait for N of them to finish
  parallelWaitFirst(...) execute several jobs in parallel,
                         wait for the first to finish
  parallelWaitAll(...)   execute several jobs in parallel,
                         wait for all of them to finish
";

LIB "parallel.lib";

proc doModular(string command, list args, def primeTest,
  def deleteUnluckyPrimes, def pTest, def finalTest, list #)
{
  /* auxiliary variables */
  int i;

  /* read optional parameters */
  int ncores_available = NbModProcs();
  list defaults = list(ncores_available, ncores_available, 2);
  for(i = 1; i <= size(defaults); i++)
  {
    if(typeof(#[i]) != typeof(defaults[i]))
    {
      # = insert(#, defaults[i], i-1);
    }
  }
  if(size(#) != size(defaults))
  {
    ERROR("wrong optional parameters");
  }
  int n1 = #[1];   // nb. of primes before the first lifting
  int n2 = #[2];   // nb. of additional primes for the next lifting
  int growths = #[3];

  /* error checking */
  if (n1 < 1 || n2 < 1 || growths < 1) {
    ERROR("wrong optional parameters");
  }
  if (typeof(primeTest) != "proc" && typeof(primeTest) != "string") {
    ERROR("incorrect argument primeTest");
  }
  if (typeof(deleteUnluckyPrimes) != "proc"
    && typeof(deleteUnluckyPrimes) != "string") {
    ERROR("incorrect argument deleteUnluckyPrimes");
  }
  if (typeof(pTest) != "proc" && typeof(pTest) != "string") {
    ERROR("incorrect argument pTest");
  }
  if (typeof(finalTest) != "proc" && typeof(finalTest) != "string") {
    ERROR("incorrect argument finalTest");
  }

  /* define procs deleteUnluckyPrimes, pTest, and finalTest */
  if (typeof(primeTest) == "string") {
    if (primeTest == "") {
      kill primeTest;
      proc primeTest = primeTest_default;
    }
    else {
      ERROR("incorrect argument primeTest");
    }
  }
  if (typeof(deleteUnluckyPrimes) == "string") {
    if (deleteUnluckyPrimes == "") {
      kill deleteUnluckyPrimes;
      proc deleteUnluckyPrimes = deleteUnluckyPrimes_default;
    }
    else {
      ERROR("incorrect argument deleteUnluckyPrimes");
    }
  }
  if (typeof(pTest) == "string") {
    if (pTest == "") {
      kill pTest;
      proc pTest = pTest_default;
    }
    else {
      ERROR("incorrect argument pTest");
    }
  }
  if (typeof(finalTest) == "string") {
    if (finalTest == "") {
      kill finalTest;
      proc finalTest = finalTest_default;
    }
    else {
      ERROR("incorrect argument finalTest");
    }
  }

  /* modular computations */
  def result;
  def result_lift;
  list modargs;
  list modresults;
  list primes;
  bigint N = 1;
  while(1) {
    // compute list of primes
    if (size(primes) == 0) {
      primes = primeList(n1, primeTest, args);
    }
    else {
      primes = primeList(n2, primeTest, args, primes[1]);
      n2 = n2*growths;
    }

    // do computation modulo several primes
    modargs = list();
    for (i = size(primes); i > 0; i--) {
      modargs[i] = list(command, args, primes[i]);
    }
    modresults = parallelWaitAll("computeInCharP", modargs);

    // delete unlucky primes
    modresults = deleteUnluckyPrimes(modresults);

    // lift result
    if (typeof(result_lift) == "none") {
      result_lift = modresults[1][1];
    }
    result_lift, N = modlift(modresults, result_lift, N);

    // apply farey()
    result = farey(result_lift, N);

    // pTest
    if(!pTest(command, args, result, primes)) {
      continue;
    }

    // finalTest
    if(finalTest(command, args, result)) {
      break;
    }
  }

  /* return of result */
  return(result);
}

static proc primeList(int n, proc primeTest, list args, list #)
{
  int i;

  /* read optional parameters */
  int p = 2147483647;
  if (size(#) > 0) {
    if (size(#) > 1 || typeof(#[1]) != "int") {
      ERROR("wrong optional parameters");
    }
    p = #[1]-1;
    if (p < 2) {
      ERROR("wrong optional parameters");
    }
  }

  /* compute primes */
  list primes;
  for (i = n; i > 0; i--) {
    if (p < 2) {
      ERROR("no more primes");
    }
    p = prime(p);
    if (!primeTest(p, args)) {
      p--;
      continue;
    }
    primes[i] = p;
    p--;
  }

  return(primes);
}

proc computeInCharP(string command, list args, int p)
{
  def br = basering;
  list lbr = ringlist(br);
  if (typeof(lbr[1]) == "int") {
    lbr[1] = p;
  }
  else {
    lbr[1][1] = p;
  }
  def rp = ring(lbr);
  setring(rp);
  list args = fetch(br, args);
  execute("def result = "+command+"("+argsToString("args", size(args))+");");
  setring(br);
  def result = fetch(rp, result);
  return(list(result, p));
}

static proc primeTest_default(int p, list args)
{
  return(1);
}

static proc deleteUnluckyPrimes_default(list modresults)
{
  return(modresults);
}

/* works so far for the following types: ideal (to be continued) */
static proc modlift(list modresults, def result, bigint N)
{
  /* copy data to lists convenient for chinrem()
   * (don't blame me, it's the stupid Singular interpreter) */
  list L1;        // the individual results
  list L2;        // the corresponding primes
  int size_modresults = size(modresults);
  if(N != 1) {
    L1[size_modresults+1] = result;
    L2[size_modresults+1] = N;
  }
  int i;
  for (i = size_modresults; i > 0; i--) {
    L1[i] = modresults[i][1];
    L2[i] = modresults[i][2];
    N = N*L2[i];
  }

  /* apply chinrem() */
  result = chinrem(L1, L2);

  /* return result */
  return(result, N);
}

static proc pTest_default
{
  return(1);
}

static proc finalTest_default
{
  return(1);
}

static proc NbModProcs()
{
    int available = system("semaphore", "get_value", 0)+1;
    int nb;
    if (available < 16) {
        nb = ((10 div available)+1-(10%available == 0))*available;
    }
    else {   // gives approx. (log_2(available))^2
        int tmp = available;
        while (tmp > 1) {
            tmp = tmp div 2;
            nb++;
        }   // nb = log_2(available)
        nb = ((2*nb+1)*available) div (2^nb) + (nb-1)^2 - 2;
    }
    return(nb);
}

